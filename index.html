<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/doc_style.css">
    <link rel="stylesheet" href="css/menu.css">
    <title>Supvisors: A Control System for Distributed Applications</title>
</head>

<body>
	<div id="body_block">

		<div id="left_side">
			<header>
				<h1><a href="https://github.com/julien6387/supvisors" target="_blank">Supvisors</a></h1>
			</header>

			<nav>
			    <ul>
                    <li><a href="#design-supervisord">Extending supervisord</a><ul>
                        <li><a href="#data-model">Data Model</a></li>
                        <li><a href="#parsing">Parsing Files</a></li>
                        <li><a href="#logging">Logging</a></li>
                        <li><a href="#supervisor-events">Supervisor Events</a></li>
						<li><a href="#inactive-addresses">Inactive Addresses</a></li>
                        <li><a href="#state-machine">State Machine</a></li>
                        <li><a href="#deployment">Deployment</a></li>
                        <li><a href="#failure">Process Failure</a></li>
                        <li><a href="#conciliation">Conciliation</a></li>
                        <li><a href="#external-io">External Interfaces</a></li>
                        <li><a href="#design-web-ext">Replacing the web pages</a></li>
                    </ul></li>
                    <li><a href="#design-supervisorctl">Extending supervisorctl</a></li>
                </ul>
			</nav>

			<footer>
				<p>Contact: <a href="mailto:julien.6387.dev@gmail.com">Julien Le Cl&eacute;ach</a></p>
				<p id="copyright">&copy; Copyright 2016-2017 Julien LE CLEACH</p>
			</footer>
		</div>

		<div id="right_side">
			<header>
				<h2>Documentation &raquo; Software Design</h2>
			</header>

			<section id="doc-contents">
				<h2 id="design-supervisord">Extending supervisord</h2>
				<p>Supvisors uses the Supervisor's XML-RPC API extension facility to add behaviour into Supervisor.<br />
				More particularly, Supvisors starts a dedicated thread <mark>inside</mark> the supervisord daemon to perform the additional work.</p>

				<h3 id="data-model">Data Model</h3>
				<p>This part presents the main structures used in the python source code of Supvisors.</p>

				<h4>ProcessStatus</h4>
				<p>Each program controlled by Supervisor is represented in a class called <code class="className">ProcessStatus</code>.<br />
				More particularly, it contains the following information:</p>
				<table class="modelTable">
					<tr><th colspan="2"><code class="className">ProcessStatus</code></th></tr>
					<tr><td><code class="attributeName">application_name</code></td><td>name of the application that the process belongs to, in other words the Supervisor group</td></tr>
					<tr><td><code class="attributeName">process_name</code></td><td>name of the process, in other words the Supervisor program name</td></tr>
					<tr><td><code class="attributeName">state</code></td><td>'synthetic' state of the process, as defined in <a href="http://supervisord.org/subprocess.html#process-states" class="extLink">Supervisor</a></td></tr>
					<tr><td><code class="attributeName">expected_exit</code></td><td>status telling if the process has exited as expected, only makes sense when state is <code>EXITED</code></td></tr>
					<tr><td><code class="attributeName">last_event_time</code></td><td>date of the last process event received from Supervisor, in remote reference time</td></tr>
					<tr><td><code class="attributeName">addresses</code></td><td>set of addresses where the process is in a <code>RUNNING</code> state<br />
						0 or 1 value is expected<br />
						if more that one value, a split-brain syndrome is happening</td></tr>
					<tr><td><code class="attributeName">processes</code></td><td>map of process information, key is <code class="attributeName">address</code></td></tr>
					<tr><td><code class="attributeName">rules</code></td><td>a <code class="className">ProcessRules</code> instance containing the deployment model of the process, as defined in the rules file</td></tr>
				</table>

				<p>Supervisor defines the following lists of states:</p>
				<pre><code class="python">STOPPED_STATES = (ProcessStates.STOPPED,
	ProcessStates.EXITED,
	ProcessStates.FATAL,
	ProcessStates.UNKNOWN)
RUNNING_STATES = (ProcessStates.RUNNING,
	ProcessStates.BACKOFF,
	ProcessStates.STARTING)</code></pre>

				<div class="note" id="synthetic-state-note">
					<p>Note about the state synthesis of a process</p>
                    <p>The state of the <code class="className">ProcessStatus</code> is a kind of synthesis based on the states declared on all Supervisor instances.<br />
                    Depending on how the program has been used on different addresses, it may be <code>STOPPED</code> on address A, <code>EXITED</code> on address B,
                    <code>RUNNING</code> on address C, etc.<br />
                    So Supvisors uses the following priority to declare the process state:</p>
                    <ul>
                        <li>the 'highest' state in <code>RUNNING_STATES</code>, with <code>RUNNING</code> &gt; <code>BACKOFF</code> &gt; <code>STARTING</code>,</li>
                        <li>the <code>STOPPING</code> state,</li>
                        <li>the last state received in <code>STOPPED_STATES</code>.</li>
                    </ul>
				</div>

				<div class="note">
					<p>Note about the decision not to use the <code class="className">Subprocess</code> class, available in Supervisor source code</p>
					<p>First, it may be impossible to point to the <code class="className">Subprocess</code> reference in supervisord config, as it may not exist.
                    Although it is recommended for the usage of Supvisors, nothing forces the user to configure all the Supervisor instances with exactly the same list of programs.
                    So when receiving a process event in the Supvisors instance B (i.e. located on address B), coming from the Supvisors instance A,
                    it may happen that the involved process is unknown to the Supervisor instance hosting B.<br />
					So, considering that a new instance of a <code class="className">Subprocess</code> could be handled in Supvisors, that raises other problems.
                    For the same reason given above, it may be impossible to assign a config to this instance. In addition to that, as a different instance of the same program
                    may be managed by every Supvisors instances, there is no guarantee that the process state transitions will be fully respected. Supvisors has to juggle with that.<br />
					Finally, <code class="className">Subprocess</code> methods and most of the information held are irrelevant to Supvisors.</p>
				</div>

				<div class="note">
					<p>Note about the process information</p>
					<p>The process information held in Supvisors looks more or less like the dictionary got from
                    the <code><a href="http://supervisord.org/api.html#supervisor.rpcinterface.SupervisorNamespaceRPCInterface.getProcessInfo" class="extLink">supervisor.getProcessInfo</a></code> XML-RPC.</p>
					<p>A few entries are removed from this dictionary, because they are useless in Supvisors and in order to improve performance: <code>description</code>, <code>stderr_logfile</code>, <code>stdout_logfile</code>, <code>logfile</code>, <code>exitstatus</code>.<br />
					A few entries are added to this dictionary: <code>localTime</code>, <code>eventTime</code>, <code>uptime</code>, <code>expected</code>.</p>
					<p>The dictionary contents are still subject to modifications.</p>
					<table>
						<caption>Process Information Dictionary</caption>
						<tr><th>Key</th><th>Value</th></tr>
						<tr><td><code>'name'</code></td><td>name of the process</td></tr>
						<tr><td><code>'group'</code></td><td>name of the group, i.e. name of the application for Supvisors</td></tr>
						<tr class="removed-entry"><td><code>'description'</code></td><td>description of the process activity</td></tr>
						<tr><td><code>'start'</code></td><td>start time of the process, in remote reference time</td></tr>
						<tr><td><code>'stop'</code></td><td>stop time of the process, in remote reference time</td></tr>
						<tr><td><code>'now'</code></td><td>current time of the process, in remote reference time</td></tr>
						<tr class="added-entry"><td><code>'local_time'</code></td><td>current time of the process, in local reference time</td></tr>
						<tr class="added-entry"><td><code>'event_time'</code></td><td>date of the last event received, in local reference time</td></tr>
						<tr class="added-entry"><td><code>'uptime'</code></td><td>age of the process</td></tr>
						<tr><td><code>'state'</code></td><td>state of the process</td></tr>
						<tr><td><code>'statename'</code></td><td>state of the process, as string</td></tr>
						<tr><td><code>'spawnerr'</code></td><td>error description when process cannot be spawned</td></tr>
						<tr class="removed-entry"><td><code>'exitstatus'</code></td><td>exit code of the process</td></tr>
						<tr class="added-entry"><td><code>'expected'</code></td><td>expected exit of the process (true, false)</td></tr>
						<tr class="removed-entry"><td><code>'logfile'</code></td><td>standard ouput of the process, deprecated</td></tr>
						<tr class="removed-entry"><td><code>'stdout_logfile'</code></td><td>standard ouput of the process</td></tr>
						<tr class="removed-entry"><td><code>'stderr_logfile'</code></td><td>error ouput of the process</td></tr>
						<tr><td><code>'pid'</code></td><td>process identifier</td></tr>
					</table>
				</div>

				<h4>ApplicationStatus</h4>
				<p>A <code class="className">ProcessStatus</code> belongs to an <code class="className">ApplicationStatus</code>.<br />
				More particularly, it contains the following information:</p>
				<table class="modelTable">
					<tr><th colspan="2"><code class="className">ApplicationStatus</code></th></tr>
					<tr><td><code class="attributeName">application_name</code></td><td>name of the application, in other words the Supervisor group</td></tr>
					<tr><td><code class="attributeName">state</code></td><td>state of the application, among:<ul>
							<li><code>UNKNOWN</code>: application state cannot be determined (initial state)</li>
							<li><code>STOPPED</code>: all processes are in <code>STOPPED_STATES</code></li>
							<li><code>STARTING</code>: at least one process is <code>STARTING</code> or <code>BACKOFF</code></li>
							<li><code>STOPPING</code>: at least one process is <code>STOPPING</code> and none is <code>STARTING</code> or <code>BACKOFF</code></li>
							<li><code>RUNNING</code>: at least one process is <code>RUNNING</code> and none is <code>STARTING</code>, <code>BACKOFF</code> or <code>STOPPING</code></li>
						</ul></td></tr>
					<tr><td><code class="attributeName">major_failure</code></td><td>indicates a required process is in <code>FATAL</code> state or is unexpectedly <code>EXITED</code>.<br />
					In this case, the application is not operational.</td></tr>
					<tr><td><code class="attributeName">minor_failure</code></td><td>indicates an optional process is in <code>FATAL</code> state or is unexpectedly <code>EXITED</code>.<br />
					this status should not affect the operational status of the application.</td></tr>
					<tr><td><code class="attributeName">processes</code></td><td>map of <code class="className">ProcessStatus</code> instances.<br />
					key is <code class="attributeName">process_name</code>.</td></tr>
					<tr><td><code class="attributeName">rules</code></td><td>an <code class="className">ApplicationRules</code> instance containing
                        the deployment model of the application, as defined in the rules file</td></tr>
				</table>

				<h4>AddressStatus</h4>
				<p>Each local Supvisors instance has its own perception of other remote Supvisors instance. This perception is stored in a class called <code class="className">AddressStatus</code>.<br />
				More particularly, it contains the following information:</p>
				<table class="modelTable">
					<tr><th colspan="2"><code class="className">AddressStatus</code></th></tr>
					<tr><td><code class="attributeName">address_name</code></td><td>address of the Supvisors instance</td></tr>
					<tr><td><code class="attributeName">state</code></td><td>state of the Supvisors instance, among:<ul>
							<li><code>UNKNOWN</code>: not active yet, no heartbeat received in <code>INITIALIZATION</code> state (default).</li>
							<li><code>CHECKING</code>: port-knocking in progress.</li>
							<li><code>RUNNING</code>: active, a heartbeat has been received in the last 10 seconds.</li>
							<li><code>SILENT</code>: inactive, no heartbeat has been received in the last 10 seconds.</li>
							<li><code>ISOLATING</code>: inactive Supvisors instance is marked for isolation when auto-fencing is activated.</li>
							<li><code>ISOLATED</code>: definitely disconnected, no more events expected anymore.</li>
						</ul></td></tr>
					<tr><td><code class="attributeName">remote_time</code></td><td>date of the last heartbeart received in remote reference time</td></tr>
					<tr><td><code class="attributeName">local_time</code></td><td>date of the last heartbeart received in local reference time</td></tr>
				</table>

				<figure>
					<img src="violet/AddressStatus.png" alt="AddressStatus statechart">
					<figcaption>AddressStatus statechart</figcaption>
				</figure>

				<p>Every time that a Supvisors instance becomes <code>RUNNING</code>, the local Supvisors instance gets and stores all process information from the Supervisor daemon using
                the <code class="python"><a href="http://supervisord.org/api.html#supervisor.rpcinterface.SupervisorNamespaceRPCInterface.getAllProcessInfo" class="extLink">supervisor.getAllProcessInfo</a></code> XML-RPC.</p>


				<h3 id="parsing">Parsing Files</h3>
				<p>Supvisors uses the python module <code class="python">supervisor.options</code> to determine the location of the configuration file and to parse it.</p>
				<pre><code class="python">from supervisor.options import Options, UnhosedConfigParser
# get supervisord.conf file from search paths
options = Options(True)
configfile = options.default_configfile()
# parse file
parser = UnhosedConfigParser()
parser.read(configfile)
parser.mysection = 'supvisors'</code></pre>

				<p>As Supervisor has a dependency with <code class="python">xml.etree.ElementTree</code>, this module has naturally been used
                to parse the rules file.<br />
				Unfortunately, this module does not provide any schema validation. So, if the module <code class="python">lxml.etree</code> is available,
                it is used <em>instead of</em> the ElementTree module to validate and parse the XML deployment.<br />
				More information about the lxml XML toolkit can be found <a href="http://lxml.de" class="extLink">here</a>.</p>
				<p>The contents of the XSD can be found in the module <code class="python">supvisors.parser</code>.
                If pushed to a file, it can be used to validate the XML file with such a shell command:</p>
				<pre><code class="bash">[bash] > xmllint --noout --schema etc/deployment.xsd etc/deployment.xml</code></pre>


				<h3 id="logging">Logging</h3>
				<p>Supvisors uses the python module <code>supervisor.loggers</code> for logging.</p>
				<pre><code class="python">from supervisor.loggers import getLogger
LOGGER_FORMAT = '%(asctime)s %(levelname)s %(message)s\n'
stdout = supervisord.options.nodaemon
logger = getLogger(logfile, loglevel, LOGGER_FORMAT, True, logfile_maxbytes, logfile_backups, stdout)</code></pre>


				<h3 id="supervisor-events">Supervisor events</h3>
				<p>As Supvisors runs inside Supervisor, it makes it possible to collect events directly by subscribing to <code>supervisor.events</code> instead of using an event listener program.</p>
				<pre><code class="python">from supervisor import events
events.subscribe(events.SupervisorRunningEvent, self.on_running)
events.subscribe(events.SupervisorStoppingEvent, self.on_stopping)
events.subscribe(events.ProcessStateEvent, self.on_process)
events.subscribe(events.Tick5Event, self.on_tick)</code></pre>

				<p>Upon notification of the <code class="python">events.SupervisorRunningEvent</code> event, the main loop thread of the Supvisors instance is started.<br />
				This thread could not be started before (when extending Supervisor XML-RPC) because it would stop if supervisord daemonizes.</p>

				<p>Upon notification of the <code class="python">events.SupervisorStoppingEvent</code> event, the main loop thread of the Supvisors instance is stopped.</p>

				<p>Supvisors creates a heartbeat message upon notification of the <code class="python">events.Tick5Event</code> events.<br />
				The date <code class="python">event.when</code> is used to fill this message.</p>

				<p>Upon notification of the <code class="python">events.ProcessStateEvent</code> events, Supvisors creates a message with the following contents:</p>
				<table>
					<caption>Process Event Dictionary</caption>
					<tr><th>Key</th><th>Value</th></tr>
					<tr><td><code>'processname'</code></td><td>name of the process</td></tr>
					<tr><td><code>'groupname'</code></td><td>name of the group, i.e. name of the application for Supvisors</td></tr>
					<tr><td><code>'state'</code></td><td>new state of the process, as a <code class="className">ProcessStates</code> value, obtained from the event type</td></tr>
					<tr><td><code>'now'</code></td><td>reception time of the process event</td></tr>
					<tr><td><code>'pid'</code></td><td>UNIX process identifier (only when state is <code>RUNNING</code>, <code>STOPPING</code>,
                        <code>STOPPED</code> or <code>EXITED</code>)</td></tr>
					<tr><td><code>'expected'</code></td><td>boolean indicating if the exit status is expected (only when state is <code>EXITED</code>)</td></tr>
				</table>

				<p>The messages are published using a ZeroMQ PUBLISH socket over a TCP socket bound on the internal_port defined
                in the Supervisor configuration file. They are sent in two parts:</p>
				<ul>
					<li>the header part, consisting in an unicode string identifying the message type,</li>
					<li>the body part, consisting of a pair <code class="python">(localAddress, payload)</code>, where payload is the event contents,
                    serialized with <em>pickle</em> (provided by <a href="http://pyzmq.readthedocs.io/en/latest/serialization.html" class="extLink">PyZMQ</a>).</li>
				</ul>
				<pre><code class="python"># example of sending Tick event
self.socket.send_string(u'tick', zmq.SNDMORE)
self.socket.send_pyobj((addressMapper.localAddress, payload))</code></pre>

				<div class="note">
					<p>Note about the localAddress</p>
					<p>When starting, the Supvisors instance has to determine its identity. More particularly, it has to find its own address among the list defined in
                    the <code class="ini">address_list</code> option of the <code class="ini">[supvisors]</code> section in the Supervisor configuration file.<br />
					So, the Supvisors instance gets the host name and all known IPv4 addresses of the host where it is running, excluding the loopback address.
                    It is expected that one element of this list MUST be an element of the <code class="ini">address_list</code></a>.
                    This element becomes the localAddress.</p>
				</div>

				<p>In Supvisors' main loop, a ZeroMQ SUBSCRIBE socket is built over a TCP socket connected to all addresses found
                in <code class="ini">address_list</code> on the <code class="ini">internal_port</code> defined in the Supervisor configuration file.<br />
				The Supvisors main loop polls the Supvisors events coming from all addresses through this socket with a timeout of one second.<br />
				Tick events are used to update the status of the <code class="className">AddressStatus</code> instances.<br />
				ProcessState events are used to update the status of the <code class="className">ProcessStatus</code> instances and consequently
                the related <code class="className">ApplicationStatus</code> instances.</p>

				<p>The timeout of the ZeroMQ poller in the Supvisors main loop is used to trigger a periodic task (every 5 seconds).
                This task is used to check the activity of the Supvisors instances and to trigger the Supvisors Machine State.</p>


				<h3 id="inactive-addresses">Inactive Addresses</h3>
				<p>The periodic task performs a verification over all the heartbeat of every Supvisors intances.<br />
				When the last heartbeat message received is older than 10 seconds, Supvisors set the state of the <code class="className">AddressStatus</code> instance to:</p>
				<ul>
					<li><code>SILENT</code> if auto-fencing <strong>is not</strong> activated,</li>
					<li><code>ISOLATING</code> if auto-fencing <strong>is</strong> activated,</li>
				</ul>
				<p>The corresponding address is then removed from all the <code class="attributeName">addresses</code> sets in the <code class="className">ProcessStatus</code> instances,
                which leads to a temporary inconsistence as the processes may be declared <code>RUNNING</code> nowhere.</p>
				<p>The next phase consists in restarting the process somewhere else, if possible, using the <a href="#deployment" class="intLink">deployment</a> function of Supvisors.<br />
				Finally, if the <code class="className">AddressStatus</code> instance was marked <code>ISOLATING</code>,
                Supvisors diconnects the corresponding url from the ZeroMQ SUBSCRIBE socket and sets the state to <code>ISOLATED</code>.<br />
				If the state is <code>SILENT</code>, Supvisors will accept the remote Supvisors instance to come back.</p>


				<h3 id="state-machine">State Machine</h3>
				<p>During the periodic task, the context of the Supvisors instance is re-evaluated.
                The State Machine of the Supvisors instance deals with the following states: <code>INITIALIZATION</code>, <code>DEPLOYMENT</code>,
                <code>OPERATION</code>, <code>CONCILIATION</code>, <code>RESTARTING</code>, <code>SHUTTING_DOWN</code>, <code>SHUTDOWN</code>.</p>

				<figure>
					<img src="violet/Supvisors.png" alt="Supvisors statechart">
					<figcaption>Supvisors statechart</figcaption>
				</figure>

				<h4>INITIALIZATION state</h4>
				<p>In the <code>INITIALIZATION</code> state, Supvisors waits for all Supvisors instances to be active.
                More particularly, heartbeat messages (or Tick events) are expected for every entry in the <code>address_list</code>.</p>

				<table class="stateTable">
					<tr><th colspan="2"><code>INITIALIZATION</code> state</th></tr>
					<tr>
						<th><img src="img/arrow-right_30.png" alt="entry"></th>
						<td>The state of all <code class="className">AddressStatus</code> instances is reset to <code>UNKNOWN</code>.<br />
						Exception is made for instances that are in <code>ISOLATED</code> state. Once a <code class="className">AddressStatus</code> instance has been isolated,
                        it is impossible to come back in any other state, so they remain in this state.</td>
					</tr>
					<tr>
						<th><img src="img/reload_30.png" alt="task"></th>
						<td>Supvisors waits until <code>synchro_timeout</code> seconds for all Supvisors instances to be active.
                        As soon as the related <code class="className">AddressStatus</code> instances are all <code>RUNNING</code>, Supvisors transitions to <code>DEPLOYMENT</code> state.<br />
						If some <code class="className">AddressStatus</code> instances are still in an <code>UNKNOWN</code> state after that delay,
                        Supvisors declares them <code>SILENT</code> (or <code>ISOLATING</code> if <code>auto_fencing</code> is activated) and transitions to <code>DEPLOYMENT</code> state with a degraded situation.</td>
					</tr>
					<tr>
						<th><img src="img/arrow-left_30.png" alt="exit"></th>
						<td>A <strong>Master</strong> is elected among the active Supvisors instances. It has been arbitrarily decided to choose the lowest address, from a 'string' point of view.</td>
					</tr>
				</table>

				<div class="note">
					<p>Note about the concept of "Master"</p>
					<p>It is necessary to choose a Master among the active Supvisors instances because only one of them will be in charge of:</p>
					<ul>
						<li>the automatic deployment of the applications,</li>
						<li>the warm restart of the lost processes, more particularly when a Supvisors instance becomes inactive,</li>
						<li>the automatic conciliation in case of conflict,</li>
						<li>the start / stop requests performed through the XML-RPC API.</li>
					</ul>
				</div>

				<h4>DEPLOYMENT state</h4>
				<p>In the <code>DEPLOYMENT</code> state, Supvisors performs an automatic deployment of the applications in accordance with the rules
                defined in the rules file and with the resources available, i.e. the set of addresses having an active Supvisors intance.</p>

				<table class="stateTable">
					<tr><th colspan="2"><code>DEPLOYMENT</code> state</th></tr>
					<tr>
						<th><img src="img/arrow-right_30.png" alt="entry"></th>
						<td>Supvisors plans the sequencing of the deployment, at the application level, in accordance with the process information loaded from
                        the remote Supersivor and the sequencing defined in the rules file.
                        As told before, nothing forces the user to configure Supervisor with the same list of programs on every addresses.
                        The sequencing has thus to take into account the actual list of programs that has been loaded from the active Supvisors instances.<br />
						The deployment starts. The principles of the function are detailed <a href="#deployment" class="intLink">hereafter</a>.</td>
					</tr>
					<tr>
						<th><img src="img/reload_30.png" alt="task"></th>
						<td>The deployment progress is checked and the next phase is triggered if any.<br />
						When the job is done, Supvisors transitions to the <code>OPERATION</code> state, unless a conflict is detected.
                        In this case, Supvisors transitions to the <code>CONCILIATION</code> state.</td>
					</tr>
					<tr>
						<th><img src="img/arrow-left_30.png" alt="exit"></th>
						<td><em>no action</em></td>
					</tr>
				</table>

				<div class="note">
					<p>Note about the unicity of the processes</p>
					<p>Although the same program definition may be loaded into the different Supervisor instances, Supvisors ensures that a single process
                    may be running among them at the same time. Of course, as the Supervisor functions are still available (through supervisorctl or ini file definitions),
                    it is easy to trick Supvisors so that multiple processes are running on several addresses.<br />
					Supvisors considers this situation, that is typically a case of <em>split-brain</em>, as a <strong>conflict</strong> and handles it
                    in the <code>CONCILIATION</code> state.<br />
					When the user really needs several instances of the same program to be running on different addresses, the solution is to set
                    the Supervisor <code class="ini">numprocs</code> option accordingly in the program definition.</p>
				</div>

				<h4>OPERATION state</h4>
				<p>In the <code>OPERATION</code> state, Supvisors checks the activity of the Supvisors instances and detects the eventual conflicts.</p>

				<table class="stateTable">
					<tr><th colspan="2"><code>OPERATION</code> state</th></tr>
					<tr>
						<th><img src="img/arrow-right_30.png" alt="entry"></th>
						<td><em>no action</em></td>
					</tr>
					<tr>
						<th><img src="img/reload_30.png" alt="task"></th>
						<td>If the Master becomes inactive, Supvisors needs a new Master to be elected and transitions to the <code>INITIALIZATION</code> state.<br />
						When a conflict is detected, Supvisors transitions to the <code>CONCILIATION</code> state.</td>
					</tr>
					<tr>
						<th><img src="img/arrow-left_30.png" alt="exit"></th>
						<td><em>no action</em></td>
					</tr>
				</table>

				<h4>CONCILIATION state</h4>
				<p>In the <code>CONCILIATION</code> state, Supvisors applies a strategy to solve the detected conflicts and waits until they are done.<br />
				In this state, the Supvisors XML-RPC dealing about starting applications or processes are ineffective but it has no impact on the Supervisor XML-RPC, that are still available.</p>

				<table class="stateTable">
					<tr><th colspan="2"><code>CONCILIATION</code> state</th></tr>
					<tr>
						<th><img src="img/arrow-right_30.png" alt="entry"></th>
						<td>The conciliation strategy set through the <code>conciliation_strategy</code> option is applied.<br />
						The principles of the function are detailed <a href="#conciliation" class="intLink">hereafter</a>.</td>
					</tr>
					<tr>
						<th><img src="img/reload_30.png" alt="task"></th>
						<td>If the Master becomes inactive, Supvisors needs a new Master to be elected and transitions to the <code>INITIALIZATION</code> state.<br />
						When a conflict is solved, Supvisors transitions back to the <code>OPERATION</code> state.</td>
					</tr>
					<tr>
						<th><img src="img/arrow-left_30.png" alt="exit"></th>
						<td>no action</td>
					</tr>
				</table>

				<h4>RESTARTING state</h4>
				<p>The <code>RESTARTING</code> state can be reached from <code>DEPLOYMENT</code>, <code>OPERATION</code> and <code>CONCILIATION</code> states, using a XML_RPC request.
                In this state, Supvisors performs an automatic stop of all applications in accordance with the rules defined
                in the rules file before a full restart.</p>

				<table class="stateTable">
					<tr><th colspan="2"><code>RESTARTING</code> state</th></tr>
					<tr>
						<th><img src="img/arrow-right_30.png" alt="entry"></th>
						<td>Supvisors plans the stopping of the applications, in accordance with the sequencing defined in
                            the rules file and starts to stop the running processes.</td>
					</tr>
					<tr>
						<th><img src="img/reload_30.png" alt="task"></th>
						<td>The stopping progress is checked and the next phase is triggered if any.<br />
						When the job is done, Supvisors transitions to the <code>SHUTDOWN</code> state.</td>
					</tr>
					<tr>
						<th><img src="img/arrow-left_30.png" alt="exit"></th>
						<td>Supvisors triggers its full restart through the restart of all Supervisor instances.</td>
					</tr>
				</table>

				<h4>SHUTTING_DOWN state</h4>
				<p>The <code>SHUTTING_DOWN</code> state can be reached from <code>DEPLOYMENT</code>, <code>OPERATION</code> and <code>CONCILIATION</code> states, using a XML_RPC request.
                In this state, Supvisors performs an automatic stop of all applications in accordance with the rules defined
                in the rules file before a full shutdown.</p>

				<table class="stateTable">
					<tr><th colspan="2"><code>SHUTTING_DOWN</code> state</th></tr>
					<tr>
						<th><img src="img/arrow-right_30.png" alt="entry"></th>
						<td>Supvisors plans the stopping of the applications, in accordance with the sequencing defined in
                            the rules file and starts to stop the running processes.</td>
					</tr>
					<tr>
						<th><img src="img/reload_30.png" alt="task"></th>
						<td>The stopping progress is checked and the next phase is triggered if any.<br />
						When the job is done, Supvisors transitions to the <code>SHUTDOWN</code> state.</td>
					</tr>
					<tr>
						<th><img src="img/arrow-left_30.png" alt="exit"></th>
						<td>Supvisors triggers its full shutdown through the shutdown of all Supervisor instances.</td>
					</tr>
				</table>

				<h4>SHUTDOWN state</h4>
				<p>The <code>SHUTDOWN</code> state is the final state. No action is performed.</p>

                
				<h3 id="deployment">Deployment</h3>
				<p>Once that Supvisors is ready to work, the starting and stopping sequences are established.<br />
                Starting and stopping applications follow the same principle.</p>

                <p>To start applications, Supvisors creates a job list and performs the following loop until there is nothing left to do:</p>
				<ul>
					<li>pop the head group of the applications from the starting sequence</li>
					<li>for all applications in this group:<ul>
                        <li>pop the head group of the processes</li>
                        <li>for all processes in this group:<ul>
                            <li>find an address, in accordance with the <code>deployment_strategy</code> option</li>
                            <li>send a <code class="python">supvisors.start_args</code> XML-RPC to the Supervisor located on that address</li>
                        </ul></li>
                        <li>wait for the processes to be <code>RUNNING</code></li>
					</ul></li>
				</ul>

				<p>Whatever the strategy applied, there are common rules to choose an address to start a process:</p>
				<ul>
					<li>the address chosen shall be one of the <code>address_list</code> defined in the Supvisors section of the Supervisor configuration file,</li>
					<li>the address chosen shall be one of the <code>addresses</code> defined in the program section of the rules file,</li>
					<li>the <code class="className">AddressStatus</code> representing this address shall be in <code>RUNNING</code>state,</li>
					<li>the sum of the <code>loading</code> values associated to the program considered and to all processes that are currently running on the address considered shall not exceed 100%.</li>
				</ul>

				<p>When applying the <code>CONFIG</code> strategy, Supvisors chooses the first address in the <code>addresses</code> list that respects the common rules.</p>
				<p>When applying the <code>LESS_LOADED</code> strategy, with respect of the common rules, Supvisors chooses the address in the <code>addresses</code> list having the lowest loading sum.<br />
				The aim is to distribute the process loading among the available hosts.</p>
				<p>When applying the <code>MOST_LOADED</code> strategy, with respect of the common rules, Supvisors chooses the address in the <code>addresses</code> list having the greatest loading sum.<br />
				The aim is to maximize the load of a host before starting to load another host. This strategy is more interesting when the resources are limited.</p>

                <p>To stop applications, Supvisors creates a job list and performs the following loop until there is nothing left to do:</p>
				<ul>
					<li>pop the head group of the applications from the stopping sequence</li>
					<li>for all applications in this group:<ul>
                        <li>pop the head group of the processes</li>
                        <li>for all processes in this group, send a <code class="python">supervisor.stopProcess</code> XML-RPC to the Supervisor located on that address</li>
                        <li>wait for the processes to be <code>STOPPED</code></li>
					</ul></li>
				</ul>


				<h3 id="failure">Process Failure</h3>
				<p>When Supervisor fails to start a process upon request, due to a problem of configuration, the process remains in <code>STOPPED</code> state.<br />
				In Supvisors, it is considered as a major failure. So, the Supervisor internal <code class="className">Subprocess</code> instance is tricked, so that an event is fired by Supervisor and the process becomes <code>FATAL</code> with an adequate <code class="attributeName">spawnerr</code> description.</p>
				<pre><code class="python">subProcess = supervisord.process_groups[applicationName].processes[processName]
# need to force BACKOFF state to go through assertion
from supervisor.states import ProcessStates
subProcess.state = ProcessStates.BACKOFF
subProcess.spawnerr = reason
subProcess.give_up()</code></pre>
				<p>The same principle has been used to set a major failure to the process if Supvisors fails to find an address where it could be started, due to a lack of resources.</p>


				<h3 id="conciliation">Conciliation</h3>
				<p>When more than one instance of the same program are running in different Supervisor daemons, it is considered as a conflict in Supvisors</p>
				<p>When applying the <code>SENICIDE</code> strategy, Supvisors keeps the <em>youngest</em> process, i.e. tha process that has been started the most recently, and stops all the others.</p>
				<p>When applying the <code>INFANTICIDE</code> strategy, Supvisors keeps the <em>oldest</em> process and stops all the others.</p>
				<p>When applying the <code>USER</code> strategy, Supvisors just waits that a user aplication solves the conflicts using <code class="bash">supervisorctl</code>, XML-RPC, process signal, or any other solution.</p>
				<p>When applying the <code>STOP</code> strategy, Supvisors stops all conflicting processes.</p>
				<p>When applying the <code>RESTART</code> strategy, Supvisors stops all conflicting processes and restarts a new one.</p>


				<h3 id="external-io">External Interfaces</h3>
				<h4>Event Interface</h4>
				<p>The process events received in the main loop are re-published using a ZeroMQ PUBLISH socket over a TCP socket <strong>locally</strong> bound on the <code>event_port</code> defined in the Supervisor configuration file. The body is serialized with <em>json</em> instead of <em>pickle</em> (also provided by <a href="http://pyzmq.readthedocs.io/en/latest/serialization.html" class="extLink">PyZMQ</a>).</p>
				<div class="note">
					<p>Note about the Supvisors Event Interface</p>
					<p>This is a local publication (bound on localhost). An applicative process can only subscribe to its co-located Supvisors instance.<br />
					It has been considered to use a <code class="python">supervisor.sendProcessStdin</code> XML-RPC to send events to applicative program but it would have too much impact on the user applicative design.</p>
				</div>

				<h4>XML-RPC</h4>
				<p>The extension point provided in Supervisor configuration file adds a plugin to the existing supervisord XML-RPC API.<br />
				The <code class="className">RPCInterface</code> class in the module <code class="python">supvisors.rpcinterface</code> follows the same principles as the <code class="className">SupervisorNamespaceRPCInterface</code> class in the module <code class="python">supervisor.rpcinterface</code>.<br />
				<p>In order to benefit from the Supervisor handling in case of exception, the <code class="className">Faults</code> class of the <code class="python">supervisor.xmlrpc</code> module is dynamically extended with the following <code class="className">SupvisorsFaults</code> values:</p>
				<pre><code class="python">SUPVISORS_CONF_ERROR=100,
BAD_SUPVISORS_STATE=101,
BAD_ADDRESS=102,
BAD_STRATEGY=103</code></pre>


				<h3 id="design-web">Replacing the web pages</h2>
                <p>Supvisors uses the HTTP server created by Supervisor but replaces the main page. This is done by modifying dynamically the contents of the <code class="python">VIEWS</code> dictionary in the module <code class="python">supervisor.web</code>.</p>
				<pre><code class="python">from supervisor.web import VIEWS
here = path.abspath(path.dirname(__file__))
# set main page
VIEWS['index.html'] =  { 'template': path.join(here, 'ui/index.html'), 'view': SupvisorsView }
# set address page
VIEWS['address.html'] =  { 'template': path.join(here, 'ui/address.html'), 'view': AddressView }
# set application page
VIEWS['application.html'] =  { 'template': path.join(here, 'ui/application.html'), 'view': ApplicationView }
# set fake page to export images
VIEWS['process_stats.png'] =  { 'template': path.join(here, 'ui/empty.html'), 'view': ProcessImageView }
VIEWS['address_stats.png'] =  { 'template': path.join(here, 'ui/empty.html'), 'view': AddressImageView }</code></pre>
                <p>The last two 'pages' are used to publish the contents of an image generated by <a href="http://matplotlib.org" class="extLink">matplotlib</a> through the HTTP server, and without writing anything on disk.</p>


				<h2 id="design-supervisorctl">Extending supervisorctl</h2>
				<p>The extension point provided in Supervisor configuration file adds a plugin to the existing supervisorctl.<br />
				The <code class="className">ControllerPlugin</code> class in the module <code class="python">supvisors.supervisorctl</code> was inspired by the <code class="className">DefaultControllerPlugin</code> class in the module <code class="python">supervisor.supervisorctl</code>.</p>

			</section>

		</div>
	</div>
</body>
</html>

